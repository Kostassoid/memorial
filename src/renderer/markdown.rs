use std::fmt::Write;
use std::time::SystemTime;
use anyhow::Result;
use time::OffsetDateTime;
use crate::model::handle::Handle;
use crate::model::knowledge::KnowledgeTree;
use crate::model::note::{Note, NoteSpan};
use crate::renderer::Renderer;

struct MarkdownRenderer {
    title: String,
    link_prefix: String,
    version: String,
}

impl MarkdownRenderer {
    fn render_node(&self, root: &KnowledgeTree, rendered: &mut String, level: usize, node: &KnowledgeTree) -> Result<()> {
        rendered.write_str(&format!(
            "{} <a id=\"{}\"></a> {}\n\n",
            "#".repeat(level),
            node.handle().as_url_safe_string(),
            Self::resolve_node_title(root, node.handle()),
        ))?;

        for n in node.notes() {
            rendered.write_str(&*Self::format_note(root, n))?;
        }

        if !node.extra().is_empty() {
            rendered.write_str("\n_Extra location:_\n")?;
            for l in node.extra() {
                rendered.write_str(&format!("- [{} (line {})]({})\n", l.path(), l.line(), l.path()))?;
            }
        }

        if !node.mentions().is_empty() {
            rendered.write_str("\n_Mentioned in:_\n")?;
            for m in node.mentions() {
                rendered.write_str(&format!("- [{}](#{})\n", m.to_string(), m.as_url_safe_string()))?;
            }
        }

        for (hp, n) in node.children() {
            self.render_node(root, rendered, level + 1, n)?;
        }

        Ok(())
    }

    fn format_note(root: &KnowledgeTree, note: &Note) -> String {
        let mut formatted = String::new();

        for s in note.spans() {
            match s {
                NoteSpan::Text(s) => {
                    formatted.write_str(&format!("{} ", s)).unwrap()
                },
                NoteSpan::Link(handle) => {
                    formatted.write_str( &format!(
                        "[{}](#{}) ",
                        Self::resolve_node_title(root, handle),
                        handle.as_url_safe_string(),
                    )).unwrap()
                }
            }
        }

        let l = note.location();
        formatted.write_str(&format!("\nSource: [{} (line {})]({})\n", l.path(), l.line(), l.path())).unwrap();

        formatted.write_str("\n\n").unwrap();

        formatted
    }

    fn resolve_node_title(root: &KnowledgeTree, handle: &Handle) -> String {
        root.find_node(handle)
            .map(|n| n.attributes().get("alias"))
            .flatten()
            .map(|s| s.to_string())
            .unwrap_or(handle.to_string())
    }
}

impl Renderer for MarkdownRenderer {
    fn render(&self, root: &KnowledgeTree) -> Result<String> {
        let mut rendered = String::new();

        self.render_node(root, &mut rendered, 1, root)?;

        rendered.write_str(&format!(
            "\n---\n<sub>Generated by [Posterity](https://github.com/Kostassoid/posterity) {} at {}.</sub>",
            &self.version,
            OffsetDateTime::from(SystemTime::now()).to_string(),
        ))?;

        Ok(rendered)
    }
}

#[cfg(test)]
mod test {
    use std::collections::HashMap;
    use std::env;
    use crate::collector::collector::Collector;
    use crate::collector::file_matcher::FileTypeMatcher;
    use crate::model::handle::Handle;
    use super::*;
    use crate::scanner::local::{LocalConfig, LocalFileScanner};
    use crate::parser::go::GoParser;

    // todo: don't have to use real files
    #[test]
    fn render_from_local_files() {
        let config = LocalConfig::new(
            env::current_dir().unwrap(),
            vec!("src/tests/**/*.go".into()),
            vec!("**/*bad*".into()),
        );

        let mut collector = Collector::new();
        collector.register_parser(FileTypeMatcher::Extension("go".to_string()), Box::new(GoParser {}));

        let scanner = LocalFileScanner::new(config).unwrap();
        collector.scan(&scanner).unwrap();

        let knowledge = collector.knowledge_mut();

        // knowledge.visit_mut(|n: &mut KnowledgeTree| {
        //     Ok(())
        // }).unwrap();

        let renderer = MarkdownRenderer {
            title: "Nice Big Title".to_string(),
            link_prefix: "https://github.com/example/".to_string(),
            version: "v0.1.0".to_string(),
        };

        knowledge.merge_attributes(
            &Handle::ROOT,
            HashMap::from([("alias".to_string(), renderer.title.clone())]),
        );

        let rendered = renderer.render(&knowledge).unwrap();
        println!("{}", rendered);
    }
}